###################################################
# Section to setup necessary env vars and overrides

DB_HOST = ENV['DB_HOST'] ? ENV['DB_HOST'] : "localhost"

DB_NAME = ENV['DB_NAME'] ? ENV['DB_NAME'] : "sli"

MONGO_BIN = ENV['MONGO_HOME'] ? ENV['MONGO_HOME']+"/bin/" : ""

EXPAND = ENV['CUKE_EXPAND'] ? "--expand" : ""

COLOR = ENV['FORCE_COLOR'] ? "-c" : ""

#######################################################

$SUCCESS=true
$failures = Hash.new

#######################################################################################################
# Helper defs

# This method is to run a given test or set of tests that have a dependency on a fixture being loaded
# Inputs: (String) testDirPath = path to a directory of tests or a single feature file (starting in acceptance-tests directory)
# Inputs: (String) collectionName = name of mongo collection to load fixture data to
# Inputs: (String) fixtureFileName = name of json file in the test/data folder
def runFixtureAndTests(testDirPath, collectionName, fixtureFileName)
  setFixture(collectionName,fixtureFileName) {runTests(testDirPath)}
end

# This method is to run a given test of set of test where a fixture is not needed
# Inputs: (String) testDirPath = path to a directory of tests or a single feature file (starting in acceptance-tests directory)
def runTests(testDirPath)
  sh "cucumber #{testDirPath} #{EXPAND} --tags ~@wip #{COLOR} -f junit --out . -f pretty" do |success, exit_code|
    if success
      $failures[testDirPath[testDirPath.rindex('/')+1..-1]] = "Passed"
    else
      $failures[testDirPath[testDirPath.rindex('/')+1..-1]] = "Failed"
      $SUCCESS=false
    end
  end
end

def setFixture(collectionName,fixtureFileName,fixtureFilePath="test/data",dropExistingCollection=true)
  #turn true/false into command line option
  dropOption = (dropExistingCollection) ? "--drop":""
  sh "#{MONGO_BIN}mongoimport #{dropOption} -d #{DB_NAME} -c #{collectionName} -h #{DB_HOST} --file #{fixtureFilePath}/#{fixtureFileName}" do |success, exit_code|
    #allow for user to pass block to run the test for each running of setFixture
    if(success && block_given?)
      yield
    else
      puts "Exited with code: #{exit_code.exitstatus}, please confirm that mongo binaries are on your PATH" unless success
    end
  end
end

def addMultipleFixtureFiles(myHash, fixtureFilePath="test/data")
  myHash.each do |key, value|
    setFixture(key,value,fixtureFilePath,false)
  end
end

def setMultipleFixtureFiles(myHash)
  myHash.each do |key, value|
    setFixture(key,value)
  end
end

def displayFailureReport()
  $failures.each do |key, value|
    puts "#{key} tests #{value}"
  end
end

############################################################################################################


######################################################################################################
# Rake tasks

task :default => :production

# Task that initializes the realm fixture.  Should only be done once
task :realmInit do
  setFixture("realm", "realm_fixture.json")
  setFixture("teacher", "teacher_fixture.json")
  setFixture("staff", "staff_fixture.json")
end

# This task will be used for end-to-end integration tests but currently just run all
# available acceptance tests
desc "Default Task: Run All Acceptances Tests"
task :production => [:apiTests, :securityTests, :ingestionTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

# This task is used as an entry point in Jenkins to run API and Security Tests
# It is needed so that it fails the build if there are any failures based on the
# 'raise' exception logic below.  Rake will exit immediatly if you raise an exception
# before all the tests complete and will show incomplete results
desc "Run API/Security Acceptances Tests"
task :apiAndSecurityTests => [:apiTests, :securityTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end


############################################################
# Ingestion tests start
############################################################
desc "Run Ingestion Acceptances Tests"
task :ingestionTests => [:studentIngestionTests, :schoolIngestionTests, :sectionIngestionTests, :studentSectionAssociationTests, :teacherSectionAssociationTests, :localEducationAgencyIngestionTests, :stateEducationAgencyIngestionTests, :educationOrganizationTests, :teacherIngestionTests, :teacherSchoolAssociationTests, :courseIngestionTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

desc "Run Student Ingestion Tests"
task :studentIngestionTests do
  runTests("test/features/ingestion/features/student.feature")
end

desc "Run School Ingestion Tests"
task :schoolIngestionTests do
  runTests("test/features/ingestion/features/school.feature")
end

desc "Run Section Ingestion Tests"
task :sectionIngestionTests do
  runTests("test/features/ingestion/features/section.feature")
end

desc "Run Student Section Association Ingestion Tests"
task :studentSectionAssociationTests do
  runTests("test/features/ingestion/features/student_section_assocation.feature")
end

desc "Run Teacher Section Association Ingestion Tests"
task :teacherSectionAssociationTests do
  runTests("test/features/ingestion/features/teacher_section_assocation.feature")
end

desc "Run Teacher School Association Ingestion Tests"
task :teacherSchoolAssociationTests do
  runTests("test/features/ingestion/features/teacher_school_assocation.feature")
end

desc "Run Education Organizations Ingestion Tests"
task :educationOrganizationTests do
  runTests("test/features/ingestion/features/education_organization.feature")
end

desc "Run State Education Agency Ingestion Tests"
task :stateEducationAgencyIngestionTests do
  runTests("test/features/ingestion/features/stateEducationAgency.feature")
end

desc "Run Local Education Agency Ingestion Tests"
task :localEducationAgencyIngestionTests do
  runTests("test/features/ingestion/features/localEducationAgency.feature")
end

desc "Run Teacher Ingestion Tests"
task :teacherIngestionTests do
  runTests("test/features/ingestion/features/teacher.feature")
end

desc "Run Course Ingestion Tests"
task :courseIngestionTests do
  runTests("test/features/ingestion/features/course.feature")
end
########
############################################################
# Ingestion tests end
############################################################

############################################################
# API tests start
############################################################
desc "Run API Acceptances Tests"
task :apiTests => [:courseTests, :sessionTests, :schoolTests, :studentTests, :teacherTests, :sectionTests, :assessmentTests, :homeUriTests, :associationTests, :validationTests, 
                   :collectionTests, :listFilterTests, :targetTests, :aggregationTests, :aggregationDiscoveryTests, :heirarchyTraversalTests, :directEntityRelationsTests] do
  displayFailureReport()
end

desc "Run Direct Entity Relations Tests"
task :directEntityRelationsTests => [:realmInit] do
  Rake::Task["importSandboxData"].execute
  runTests("test/features/api/associations/directEntityRelations")
end

desc "Run Heirachy Traversal Tests"
task :heirarchyTraversalTests => [:realmInit] do
  Rake::Task["importSandboxData"].execute
  runTests("test/features/api/end_user_stories/heirarchyTraversal")
end

desc "Run Course Tests"
task :courseTests => [:realmInit] do
  runFixtureAndTests("test/features/api/entities/course", "course", "course_fixture.json")
end

desc "Run Session Tests"
task :sessionTests => [:realmInit] do
  runFixtureAndTests("test/features/api/entities/session", "session", "session_fixture.json")
end

desc "Run Section Tests"
task :sectionTests => [:realmInit] do
  runFixtureAndTests("test/features/api/entities/section", "section", "section_fixture.json")
end

desc "Run School Tests"
task :schoolTests => [:realmInit] do
  runFixtureAndTests("test/features/api/entities/school", "school", "school_fixture.json")
end

desc "Run Student Tests"
task :studentTests => [:realmInit] do
  runFixtureAndTests("test/features/api/entities/student", "student", "student_fixture.json")
end

desc "Run Teacher Tests"
task :teacherTests => [:realmInit] do
  runFixtureAndTests("test/features/api/entities/teacher", "teacher", "teacher_fixture.json")
end

desc "Run Assessment Tests"
task :assessmentTests => [:realmInit] do
  runFixtureAndTests("test/features/api/entities/assessment","assessment","assessment_fixture.json")
end

desc "Run Validation Tests"
task :validationTests => [:realmInit] do
  setFixture("school", "school_fixture.json")
  setFixture("teacher", "teacher_fixture.json")
  setFixture("student", "student_fixture.json")
  runTests("test/features/api/validation")
end

desc "Run List-Filter Tests"
task :listFilterTests => [:realmInit] do
  Rake::Task["importSandboxData"].execute
  runTests("test/features/api/end_user_stories/lists")
end

desc "Run Target Tests"
task :targetTests => [:realmInit] do
  Rake::Task["importSandboxData"].execute
  runTests("test/features/api/end_user_stories/targets")
end

desc "Run Collection Tests"
task :collectionTests => [:realmInit] do
  files = {
    "school" => "school_fixture.json",
    "student" => "student_fixture.json",
    "studentSchoolAssociation" => "studentSchoolAssociation_fixture.json"
  }
  setMultipleFixtureFiles(files)
  runTests("test/features/api/collections")
end

# dependecy on importSandboxData so that association tests can depend on the associated
# entiy data to be available
desc "Run Association Tests"
task :associationTests => [:realmInit] do
  Rake::Task["importSandboxData"].execute
  runTests("test/features/api/associations/educationOrganization_association")
  runTests("test/features/api/associations/student_section_association")
  runTests("test/features/api/associations/student_assessment_association")
  runTests("test/features/api/associations/student_school_association")
  runTests("test/features/api/associations/teacher_school_association")
  runTests("test/features/api/associations/teacher_section_association")
  runTests("test/features/api/associations/school_session_association")
  runTests("test/features/api/associations/session_course_association")
end

desc "Run Home URI Tests"
task :homeUriTests => [:realmInit] do
  Rake::Task["importSandboxData"].execute
  runTests("test/features/api/home_uri")
end

desc "Run Aggregation Tests"
task :aggregationTests => [:realmInit] do
  Rake::Task["importSandboxData"].execute
  runTests("test/features/api/end_user_stories/aggregates")
end

desc "Run Aggregation Discovery Tests"
task :aggregationDiscoveryTests => [:realmInit] do
  runFixtureAndTests("test/features/api/aggregations","aggregation","aggregation_fixture.json")
end
############################################################
# API tests end
############################################################

############################################################
# API Selenium tests start
# NOTE: Do not add these tests to the production run yet!
#       While they can be run locally without issues,
#       Firefox cannot start on Jenkins, and will cause
#       all these tests to fail
############################################################
desc "Run API Selenium Tests"
task :apiSeleniumTests do
  runTests("test/features/apiSelenium")
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end
############################################################
# API Selenium tests end
############################################################

############################################################
# Security tests start
############################################################
desc "Run Security Tests"
task :securityTests => [:realmInit] do
  Rake::Task["importSandboxData"].execute
  runTests("test/features/security")
end
############################################################
# Security tests end
############################################################

############################################################
# Dashboard tests start
############################################################
desc "Run Dashboard Tests"
task :dashboardTests => [:dashboardPopWidgetTests] do
  puts "Completed Dashboard tests"
end

desc "Run Dashboard population widget Tests"
task :dashboardPopWidgetTests do
  runTests("test/features/dashboard/population_widget.feature")
end

desc "Run Dashboard K-3 view Tests"
task :dashboardK3ViewTests do
  runTests("test/features/dashboard/k3view.feature")
end

desc "Run Dashboard High School view Tests"
task :dashboardHSViewTests do
  runTests("test/features/dashboard/high_school_view.feature")
end

desc "Run Dashboard Program Participation and Student Info Tests"
task :dashboardLozengesTests do
  runTests("test/features/dashboard/lozenges.feature")
end

desc "Run Dashboard YY Tests"
task :dashboardTests do
  runTests("test/features/dashboard")

end

desc "Run Dashboard user based view selection tests"
task :dashboardUserBasedViewTests do
  runTests("test/features/dashboard/user_based_views.feature")
end

desc "Run Dashboard integration acceptance tests"
task :dashboardIntegratedTests do
    runTests("test/features/dashboard/dashboard_api_integration.feature")
end
############################################################
# Dashboard tests end
############################################################

desc "Import Sandbox Test Data"
task :importSandboxData do
  testHash = Hash[
    "section" => "section_fixture.json",
    "course" => "course_fixture.json",
    "school" => "school_fixture.json",
    "student" => "student_fixture.json",
    "teacher" => "teacher_fixture.json",
    "staff" => "staff_fixture.json",
    "assessment" => "assessment_fixture.json",
    "studentSchoolAssociation" => "studentSchoolAssociation_fixture.json",
    "teacherSectionAssociation" => "teacherSectionAssociation_fixture.json",
    "studentAssessmentAssociation" => "studentAssessmentAssociation_fixture.json",
    "studentSectionAssociation" => "studentSectionAssociation_fixture.json",
    "teacherSchoolAssociation" => "teacherSchoolAssociation_fixture.json",
    "educationOrganization" => "educationOrganization_fixture.json",
    "educationOrganizationSchoolAssociation" => "school_educationOrganization_fixture.json",
    "educationOrganizationAssociation" => "educationOrganizationAssociation_fixture.json",
    "aggregationDefinition" => "aggregationdefinition_fixture.json",
    "staffEducationOrganizationAssociation" => "staffEducationOrganizationAssociation_fixture.json",
    "schoolSessionAssociation" => "schoolSessionAssociation_fixture.json",
    "sessionCourseAssociation" => "sessionCourseAssociation_fixture.json"
  ]
  setMultipleFixtureFiles(testHash)

  smallvilleTestHash = Hash[
    "assessment" => "smallville_assessment_fixture.json",
    "course" => "smallville_courses_fixture.json",
    "courseSectionAssociation" => "smallville_course_section_association_fixture.json",
    "sessionCourseAssociation" => "smallville_course_session_association_fixture.json",
    "educationOrganizationAssociation" => "smallville_edOrg_edOrg_association_fixture.json",
    "educationOrganization" => "smallville_edOrg_fixture.json",
    "school" => "smallville_schools_fixture.json",
    "educationOrganizationSchoolAssociation" => "smallville_school_edOrg_fixture.json",
    "schoolSessionAssociation" => "smallville_school_session_association_fixture.json",
    "section" => "smallville_sections_fixture.json",
    "sectionAssessmentAssociation" => "smallville_section_assessment_fixture.json",
    "session" => "smallville_sessions_fixture.json",
    "student" => "smallville_students_fixture.json",
    "studentAssessmentAssociation" => "smallville_student_assessment_fixture.json",
    "studentSchoolAssociation" => "smallville_student_school_association_fixture.json",
    "studentSectionAssociation" => "smallville_student_section_association_fixture.json",
    "teacher" => "smallville_teachers_fixture.json",
    "teacherSectionAssociation" => "smallville_teacher_sections_fixture.json",
    "sectionSchoolAssociation" => "smallville_section_school_association_fixture.json"
  ]
  addMultipleFixtureFiles(smallvilleTestHash, "test/data/smallville")
end



desc "Help information for this Rakefile"
task :help do
  puts <<-eos
This Rakefile assumes one of two things: an environment variable MONGO_HOME
is set to the home directory of mongo (just before bin) or that the mongo binaries
are on your PATH.

By default, the tests run against the deployed API/application that is running on
localhost:8080 and also assumes a mongo server running on localhost (at default port).

By default, any Scenario Outlines will be expanded in the console output for ease of development,
but at the command line, the env var "NO_EXPAND" may be defined to run without expanding the Scenario
Outline to allow for proper JUnit XML output files for display in Jenkins

To change this behavior use the following syntax to override:

cmd>rake property=value <rake Task>

Example:

cmd>rake DB_HOST=myNewDbHost.domain.name api_server_url=my.API.server.com production

The properties available to override are as follows:

DB_HOST                This property selects which mongo instance to set the fixture to (default: localhost)
DB_NAME                This property selects which mongo db to set the fixture to (default: sli)
api_server_url         This property selects which running instance of the API to run tests against (default: localhost)
admintools_server_url  This property selects which running instance of the Admin Tools to run tests against (default: localhost)
sli_idp_server_url     This property selects which running IDP should be used as the SLI IDP (default http://devdanil.slidev.org:8080/idp)
sea_idp_server_url     This property selects which running IDP should be used as a mock State IDP (default http://devopenam1.slidev.com:8080/idp1)
lea_idp_server_url     This property selects which running IDP should be used as a mock District IDP (default http://devopenam1.slidev.com:8080/idp2)
DEBUG                  This property tells the test code to display debug output in the console
CUKE_EXPAND            This property tells cucumber to expand Scenario Outlines (for use in jenkins, default: not expand)
eos

end
